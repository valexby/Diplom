\section{ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:functional}
Ниже будет описана работа разрабатываемого проекта и представлена информация о структуре программного продукта.

В проекте использован объектно-ориентированный подход, поэтому код проекта разделён на классы. Каждый класс выполняет свою уникальную функцию или расширяет функционал, предоставляемый фреймворком и сторонними библиотеками. Для взаимодействия всех классов и для интеграции проекта с дополнительными библиотеками используются файлы конфигурации.

Так же, так как сбор статистики и анализ тональностей --- независимые друг от друга задачи, то проект представляет собой два приложения, управляемые внешним скриптом.
\subsection{Структура проекта}
Разрабатываемый проект разделен на несколько каталогов:
\begin{itemize}
\item data\_gather --- хранит код сбора данных;
\item sentiment --- хранит код анализатора тональностей;
\item data --- хранит временные данные программы и входные данные;
\item javascript --- хранит код модуля визуализации;
\item treebank --- хранит код скриптов предобработки наборов данных.
\end{itemize}
\subsection{Структура базы данных}
Модель данных, иллюстрирующая таблицы базы данных и связи между ними приведена на чертеже ГУИР.400201.009 РР.3. В качестве базы данных была использована MySQL\@. Как видно из чертежа, для реализации связей один ко многим были использованы удаленные ключи, а для реализации связей много ко многим были созданы ассоциативные таблицы.
\subsection{Объектно-реляционное отображение}
В Python существует возможность не обращаться на прямую к базе данных. Это можно сделать при помощи \texttt{Sqlalchemy} --- инструмента объектно-реляционного отображения. \texttt{Sqlalchemy} предоставляет удобный функционал для работы с базами данных. В программной модели создается класс, соответствующий какой-то таблице из модели данных, и наследуется от класса \texttt{sqlalchemy.Model}. Используя магическое поле \texttt{\_\_tablename\_\_} указывается таблица, которой соответствует данный класс. Затем задаются поля класса, соответствующие столбцам таблицы базы данных, инстанцированные от класса \texttt{sqlalchemy.Column}. Так же указывается тип данных, который столбец имеет в базе данных. Затем описываются отношения с другими таблицами. Для этого предназначен модуль \texttt{sqlalchemy.orm}. С помощью функции \texttt{relationship} данного модуля можно задать простую связь, соответствующую удаленному ключу в базе данных. Существуют так же инструменты для реализации более сложных видов связей, вроде ассоциативных таблиц. Однако, инструмент ассоциативных таблиц не был использован в объектно-реляционном отображении в данном проекте, несмотря на то что данные таблицы широко используются в проекте для реализации связей вида много ко многим.

Пример объектно-реляционного отображения таблицы \texttt{item} показан ниже:

\medskip
\begin{lstlisting}[style=Python]
class Item(Base, DeclarativeBase):
    """The model for Item data"""
    __tablename__ = "item"

    id = sa.Column(sa.Integer, primary_key=True)
    name = sa.Column(VARCHAR(100, charset='utf8'), unique=True)
    cost = sa.Column(sa.Integer, primary_key=True)
    rating = sa.Column(sa.Integer, primary_key=True)
    state = sa.Column(VARCHAR(100, charset='utf8'), unique=True)
    number = sa.Column(sa.Integer, primary_key=True)
    sold = sa.Column(sa.Integer, primary_key=True)

    seller = orm.relationship("Seller", back_populates="items")
    store = orm.relationship("Store", back_populates="items")
\end{lstlisting}
\medskip

Как видно из приведенной на чертеже ГУИР.400201.009 РР.1 диаграммы классов, все таблицы модели данных имеют соответствующий класс в программной модели.

Класс \texttt{models.Category} представляет категорию товаров онлайн магазина. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название категории.

Класс \texttt{models.ItemSubCategory} представляет подкатегорию товара в онлайн магазине. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer}, \texttt{name} типа \texttt{sqlalchemy.String} и \texttt{category} типа \texttt{models.Category} хранят соответственно идентификатор в базе данных, название подкатегории и сслыку на объект категории, к которой данная подкатегория принадлежит. Так как подкатегория --- это составная часть категории, то при удалении объекта категории должен удаляться и объект подкатегории, на который ссылается объект категории, то между ним устанавливается связь типа композиции, направленная от подкатегории к категории.

Класс \texttt{models.CategoryLink} представляет ассоциативную таблицу для связи товара с его подкатегорией. Так как каждый товар может состоять в произвольном количестве подкатегорий, а подкатегория может содержать произвольное количество товаров, то между ними связь вида много ко многим. Поэтому у класса два поля: \texttt{sub\_category} типа \texttt{models.ItemSubCategory} и \texttt{item} типа \texttt{models.Item}, которые являются ссылками на объекты подкатегории и товара. Соответственно каждый объект данного класса связывает два объекта товара и подкатегории. Так как при разрушении объекта подкатегории, или при разрушении объекта товара связь между ними теряет смысл, то объект типа \texttt{models.CategoryLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы исходит две связи типа композиции: одна в сторону подкатегории товара, другая в сторону товара.

Класс \texttt{models.Item} представляет товар интернет магазина. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и наименование товара. Далее поля \texttt{cost} типа \texttt{sqlalchemy.Integer}, \texttt{rating} типа \texttt{sqlalchemy.Integer}, \texttt{state} типа \texttt{sqlalchemy.String}, \texttt{number} типа \texttt{sqlalchemy.Integer} и \texttt{sold} типа \texttt{sqlalchemy.Integer} хранят соответственно цену товара, рейтинг товара, состояние, количество товара в наличии и товара продано. Затем два поля \texttt{seller} типа \texttt{models.Seller} и \texttt{store} типа \texttt{models.Store} хранят ссылки на объекты продавца и магазина соответственно.

Класс \texttt{models.Store} представляет магазин интернет площадки. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название магазина. Так как магазин является лишь композицей для товаров, то товар может существовать без магазина, верно и обратное --- магазин может существовать без товара. Поэтому между классами \texttt{models.Item} и \texttt{models.Store} образована свзяь типа агрегация.

Класс \texttt{models.Achievement} представляет собой достижение магазина интернет площадки. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и название достижения.

Так как каждый магазин может иметь произвольное количество достижений, а каждое достижение может принадлежать нескольким магазинам, то между достижением и магазином связь много ко многим. Поэтому класс \texttt{models.AchivementLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом достижения и объектом магазина. Ссылки на эти объекты хранятся в публичных полях \texttt{seller} типа \texttt{models.Seller} и \texttt{achievement} типа \texttt{models.Achievement}. Так как при разрушении объекта достижения, или при разрушении объекта магазина связь между ними теряет смысл, то объект типа \texttt{models.AchievementLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.AchivementLink} исходит две связи типа композиции: одна в сторону достижения \texttt{models.Achievement}, другая в сторону магазина \texttt{Store}.

Класс \texttt{models.Seller} представляет собой описание продавца интернет магазина. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и логин продавца. Так же он имеет поля \texttt{description\_rating} типа \texttt{sqlalchemy.Integer}, \texttt{communication\_rating} типа \texttt{sqlalchemy.Integer}, \texttt{timing\_rating} типа \texttt{sqlalchemy.Integer} и \texttt{delivery\_cost\_rating} типа \texttt{sqlalchemy.Integer} которые хранят соответственно рейтинги продавца по следующим параметрам:
\begin{itemize}
\item рейтинг точности составления описания;
\item рейтинг общения с продавцом;
\item рейтинг своевременности доставки;
\item рейтинг удовлетворенностью ценой доставки.
\end{itemize}
При удалении товара объект продавца должен быть сохранен. А при удалении объекта продавца объект товара должен быть сохранен. Но так как объект товара имеет ссылку на продавца, то от класса \texttt{models.Item} направлена связь типа агрегация в сторону класса \texttt{models.Seller}. Также, класс \texttt{models.Store} связан с классом \texttt{models.Seller} отношением типа ассоциация, из-за того, что между ними может существовать косвенная связь, вплоть до того, что продавец и магазин будут отражать один и тот же объект. То есть продавец может оказаться частью магазина в модели интернет площадки, а может быть и самостоятельным объектом.

Класс \texttt{models.User} представляет объект пользователя. Идентификатор объекта в базе данных и логин пользователя хранятся соответственно в полях \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{login} типа \texttt{sqlalchemy.String}. Публичные поля \texttt{addres} типа \texttt{sqlalchemy.String}, \texttt{country} типа \texttt{sqlalchemy.String}, \texttt{state} типа \texttt{sqlalchemy.String}, \texttt{rating} типа \texttt{sqlalchemy.Integer} и \texttt{birth\_date} типа \texttt{sqlalchemy.Date} хранят соответственно адрес доставки пользователя, страна, время последнего выхода в онлайн, рейтинг пользователя и дата рождения.

Класс \texttt{models.Genre} представляет жанр фильма на форуме о кино. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название жанра кино.

Так как каждый фильм может принадлежать к произвольному количеству жанров, а каждый жанр может быть присвоен нескольким фильмам, то между жанром и фильмом связь много ко многим. Поэтому класс \texttt{models.GenreLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом жанра и объектом фильма. Ссылки на эти объекты хранятся в публичных полях \texttt{genre} типа \texttt{models.Genre} и \texttt{film} типа \texttt{models.Film}. Так как при удалении объекта жанра, или при разрушении объекта фильма связь между ними теряет смысл, то объект типа \texttt{models.GenreLink}, связывавший данную пару, также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.GenreLink} исходит две связи типа композиции: одна в сторону жанра \texttt{models.Genre}, другая в сторону фильма \texttt{models.Film}.

Класс \texttt{models.Film} представляет собой объект фильма на тематическом форуме. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{title} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и название фильма. Информация о дате выхода фильма в прокат, страна производства фильма и бдюжет хранится соответственно в полях: \texttt{year} типа \texttt{sqlalchemy.Date}, \texttt{country} типа \texttt{sqlalchemy.String} и \texttt{budget} типа \texttt{sqlalchemy.Integer}.

Класс \texttt{models.Actor} представляет актера кино на тематическом форуме. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и имя актера.

Так как в каждом фильме может сниматься произвольное количество актеров, а каждый актер может играть роли в произвольном количестве фильмов, то между актером и фильмом связь много ко многим. Поэтому класс \texttt{models.ActorLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом фильма и объектом актера. Ссылки на эти объекты хранятся в публичных полях \texttt{actor} типа \texttt{models.Actor} и \texttt{film} типа \texttt{models.Film}. Так как при удалении объекта актера, или при разрушении объекта фильма связь между ними теряет смысл, то объект типа \texttt{models.ActorLink}, связывавший данную пару, также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.ActorLink} исходит две связи типа композиции: одна в сторону класса актера \texttt{models.Actor}, другая в сторону фильма \texttt{models.Film}.

Класс \texttt{models.Treebank} представляет собой отображение набора синтаксических деревьев, хранящихся в базе данных. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название набора данных. Название набора данных выбирается одно из ряда:
\begin{itemize}
\item \texttt{sst\_dev};
\item \texttt{sst\_test};
\item \texttt{sst\_train};
\item \texttt{film\_reviews};
\item \texttt{item\_reviews};
\item \texttt{seller\_reviews}.
\end{itemize}
Код \texttt{sst} обозначает Stanford Sentiment Treebank --- Стенфордский набор данных. Так же в базе хранятся наборы данных созданные из обзоров на фильмы, полученные из тематического форума --- \texttt{film\_reviews}, из онлайн магазина --- \texttt{item\_reviews}, и также обзоры на продавцов --- \texttt{seller\_reviews}.

Класс \texttt{models.ItemReview} представляет обзор на товар в интернет магазине. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{review\_text} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и текст отзыва на товар. Оценка товара пользователем хранится в публичном поле \texttt{item\_grade} типа \texttt{sqlalchemy.Integer}. Автор отзыва указан ссылкой на объект пользователя в публичном поле \texttt{user} типа \texttt{models.User}. Так как при удалении пользователя, обзор теряет силу и значимость, то необходимо удалять вслед за этим и объект обзора на товар. Таким образом от класса \texttt{models.ItemReview} направлена связь вида конмозиция в сторону класса \texttt{models.User}. В поле \texttt{item} типа \texttt{models.Item} хранится ссылка на объект товара, описанного в данном объекте отзыва. При удалении объекта товара, который описывает текущий объект отзыва на товар, то отзыв на товар так же должен быть удален. Следовательно, от класса \texttt{models.ItemReview} направлена связь типа композиция в сторону класса \texttt{models.Item}. Также \texttt{models.ItemReview} хранит ссылку на объект синтаксического дерева, в публичном поле \texttt{tree} типа \texttt{models.Tree}. Так как объект синтаксического дерева хранит текст отзыва в формате синтаксического дерева, то при удалении объекта отзыва, объект синтаксического дерева должен быть так же удален. Значит, от класса \texttt{models.Tree} направлена связь типа композиция в сторону класса \texttt{models.ItemReview}.

Класс \texttt{models.Director} представляет режиссера кино на тематическом форуме. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и имя режиссера.

Так как в каждом фильме может участвовать произвольное количество режиссеров, а каждый режиссер может снимать произвольное количество фильмов, то между режиссером и фильмом связь много ко многим. Поэтому класс \texttt{models.DiretorLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом фильма и объектом режиссера. Ссылки на эти объекты хранятся в публичных полях \texttt{director} типа \texttt{models.Director} и \texttt{film} типа \texttt{models.Film}. Так как при удалении объекта режиссера, или при разрушении объекта фильма связь между ними теряет смысл, то объект типа \texttt{models.DirectorLink}, связывавший данную пару, также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.DirectorLink} исходит две связи типа композиции: одна в сторону класса режиссера \texttt{models.Director}, другая в сторону фильма \texttt{models.Film}.

Класс \texttt{models.Tree} представляет объект синтаксического дерева. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{json} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и представление синтаксического дерева в формате JSON\@. Поле \texttt{treebank} типа \texttt{models.Treebank} хранит ссылку на объект набора данных. Так как синтаксическое дерево может быть независимым и не входить ни в один из наборов данных, но иимеет поле ссылки на \texttt{models.Treebank}, то между классами набора данных и синтаксического дерева создается связь вида агрегация направленная он \texttt{models.Tree} в сторону \texttt{models.Treebank}.
\subsection{Модуль сбора статистики}
Модуль сбора статистики, описанный в downloader.py в виде класса Downloader, осуществляет сбор статистики с интернет ресурсов, и сохраняет её в базе данных. Для работы с базой класс имеет поля \texttt{session} типа \texttt{sqlalchemy.Session} и \texttt{db\_driver} типа \texttt{sqlalchemy.DbDriver}. В объекте \texttt{db\_driver} содержится информация о подключении к базе данных:
\begin{itemize}
\item база данных (MySQL\@ или PostgreSQL\@)
\item драйвер базы данных для \texttt{Python} (напрмер \texttt{oursql} или \texttt{pymysql})
\item адрес хоста базы;
\item имя базы;
\item логин;
\item пароль.
\end{itemize}
Далее он имеет конфигурируемые переменные \texttt{FILM\_TOKEN\_LEN} и \texttt{ITEM\_TOKEN\_LEN}, заданные глобально в модуле Python. Это стандартная практика для защиты конфигурации. Данные переменные задают количество скачиваемых объектов за один REST запрос для фильмов и товаров соответственно. В константах \texttt{STORE\_URL} и \texttt{FILM\_FORUM\_URL} хранятся URL целевых ресурсов. Массивы \texttt{item\_reviews}, \texttt{seller\_reviews} и \texttt{film\_reviews} хранят соответственно объекты реляционного отображения таблиц с отзывами.

Класс \texttt{Downloader} содежрит набор схожих методов:
\begin{itemize}
\item \texttt{get\_items};
\item \texttt{get\_film};
\item \texttt{get\_categories};
\item \texttt{get\_stores};
\item \texttt{get\_sellers};
\item \texttt{get\_achivements};
\item \texttt{get\_actors};
\item \texttt{get\_directors};
\item \texttt{get\_subcategories}.
\end{itemize}

Задача данных методов в том, чтобы преобразовать полученный от интернет ресурса GET ответ в формате JSON в объек объектно реляциоонного отображения, создав тем самым соответствующую запись в базе данных. Каждый из этих методов имеет константу, хранящую часть путь в URL адресе. Далее имеется переменная {\texttt{params}} типа \texttt{dict}, хранящая параметры REST запросов. Пример объявления \texttt{params} показан ниже:

\medskip
\begin{lstlisting}[style=Python]
  params = {'sortBy': 'recentlyCreated',
    'group': 'general',
    'page': 1,
    'pageSize': self.FILM_PAGE_SIZE}
\end{lstlisting}
\medskip

Переменная \texttt{response} типа хранит ответы на REST запросы. Так же множество различных локальных переменных введены для хранения промежуточных результатов преобразования из JSON в объект. Методы \texttt{save\_film\_info} и \texttt{save\_item\_info} формируют конечную транзацкию в базу данных.

Наконец, задача метода \texttt{get\_missing} проверить целостность данных в базе. Для этого используется схожий набор переменных: \texttt{params} и \texttt{response} для управления REST запросами. Для проверки целостности со стороны клиента используются массивы класса \texttt{item\_reviews}, \texttt{seller\_reviews} и \texttt{film\_reviews}.
