\section{ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:functional}
Ниже будет описана работа разрабатываемого проекта и представлена информация о структуре программного продукта.

В проекте использован объектно-ориентированный подход, поэтому код проекта разделён на классы. Каждый класс выполняет свою уникальную функцию или расширяет функционал, предоставляемый фреймворком и сторонними библиотеками. Для взаимодействия всех классов и для интеграции проекта с дополнительными библиотеками используются файлы конфигурации.

Так же, так как сбор статистики и анализ тональностей --- независимые друг от друга задачи, то проект представляет собой два приложения, управляемые внешним скриптом.
\subsection{Структура проекта}
Разрабатываемый проект разделен на несколько каталогов:
\begin{itemize}
\item data\_gather --- хранит код сбора данных;
\item sentiment --- хранит код анализатора тональностей;
\item data --- хранит временные данные программы и входные данные;
\item javascript --- хранит код модуля визуализации;
\item treebank --- хранит код скриптов предобработки наборов данных.
\end{itemize}
\subsection{Структура базы данных}
Модель данных, иллюстрирующая таблицы базы данных и связи между ними приведена на чертеже ГУИР.400201.009 РР.3. В качестве базы данных была использована MySQL\@. Как видно из чертежа, для реализации связей один ко многим были использованы удаленные ключи, а для реализации связей много ко многим были созданы ассоциативные таблицы.
\subsection{Объектно-реляционное отображение}
В Python существует возможность не обращаться на прямую к базе данных. Это можно сделать при помощи \texttt{Sqlalchemy} --- инструмента объектно-реляционного отображения. \texttt{Sqlalchemy} предоставляет удобный функционал для работы с базами данных. В программной модели создается класс, соответствующий какой-то таблице из модели данных, и наследуется от класса \texttt{sqlalchemy.Model}. Используя магическое поле \texttt{\_\_tablename\_\_} указывается таблица, которой соответствует данный класс. Затем задаются поля класса, соответствующие столбцам таблицы базы данных, инстанцированные от класса \texttt{sqlalchemy.Column}. Так же указывается тип данных, который столбец имеет в базе данных. Затем описываются отношения с другими таблицами. Для этого предназначен модуль \texttt{sqlalchemy.orm}. С помощью функции \texttt{relationship} данного модуля можно задать простую связь, соответствующую удаленному ключу в базе данных. Существуют так же инструменты для реализации более сложных видов связей, вроде ассоциативных таблиц. Однако, инструмент ассоциативных таблиц не был использован в объектно-реляционном отображении в данном проекте, несмотря на то что данные таблицы широко используются в проекте для реализации связей вида много ко многим.

Пример объектно-реляционного отображения таблицы \texttt{item} показан ниже:

\medskip
\begin{lstlisting}[style=Python]
class Item(Base, DeclarativeBase):
    """The model for Item data"""
    __tablename__ = "item"

    id = sa.Column(sa.Integer, primary_key=True)
    name = sa.Column(VARCHAR(100, charset='utf8'), unique=True)
    cost = sa.Column(sa.Integer, primary_key=True)
    rating = sa.Column(sa.Integer, primary_key=True)
    state = sa.Column(VARCHAR(100, charset='utf8'), unique=True)
    number = sa.Column(sa.Integer, primary_key=True)
    sold = sa.Column(sa.Integer, primary_key=True)

    seller = orm.relationship("Seller", back_populates="items")
    store = orm.relationship("Store", back_populates="items")
\end{lstlisting}
\medskip

Как видно из приведенной на чертеже ГУИР.400201.009 РР.1 диаграммы классов, все таблицы модели данных имеют соответствующий класс в программной модели.

Класс \texttt{models.Category} представляет категорию товаров онлайн магазина. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название категории.

Класс \texttt{models.ItemSubCategory} представляет подкатегорию товара в онлайн магазине. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer}, \texttt{name} типа \texttt{sqlalchemy.String} и \texttt{category} типа \texttt{models.Category} хранят соответственно идентификатор в базе данных, название подкатегории и сслыку на объект категории, к которой данная подкатегория принадлежит. Так как подкатегория --- это составная часть категории, то при удалении объекта категории должен удаляться и объект подкатегории, на который ссылается объект категории, то между классами \texttt{models.ItemSubCategory} и \texttt{models.Category} устанавливается связь типа композиции, направленная от подкатегории к категории, как видно из приведенной на чертеже ГУИР.400201.009 РР.1 диаграммы классов.

Класс \texttt{models.CategoryLink} представляет ассоциативную таблицу для связи товара с его подкатегорией. Так как каждый товар может состоять в произвольном количестве подкатегорий, а подкатегория может содержать произвольное количество товаров, то между ними связь вида много ко многим. Таким образом, каждый объект класса данной ассоциативной таблицы представляет связь между объектом подкатегории и объектом товара. Класс \texttt{mo\-dels.CategoryLink} имеет публичное поле \texttt{sub\_category} типа \texttt{models.Item\-SubCategory}, которое хранит ссылку на объект класса подкатегории. При удалении подкатегории свзяь так же должна разрушаться. Поэтому из класса ассоциативной таблицы \texttt{models.CategoryLink} исходит связь вида композиция в сторону класса подкатегории \texttt{models.ItemSubCategory}, что видно из диаграммы классов на чертеже ГУИР.400201.009.РР1.1. Также \texttt{models.Cate\-goryLink} хранит ссылку на объект товара в публичном поле \texttt{item} типа \texttt{mo\-dels.Item}. Так как при разрушении объекта товара связь между товаром и подкатегорией теряет смысл, то объект типа \texttt{models.CategoryLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{mo\-dels.CategoryLink} исходит связь типа композиции в сторону класса товара \texttt{Item}. Данная композиция отражена на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1.

Следующие классы являются объектно-реляционными отображениями:
\begin{itemize}
\item \texttt{models.Category};
\item \texttt{models.ItemSubCategory};
\item \texttt{models.CategoryLink};
\item \texttt{models.Item};
\item \texttt{models.Store};
\item \texttt{models.AchievementLink};
\item \texttt{models.Achievement};
\item \texttt{models.Seller};
\item \texttt{models.User};
\item \texttt{models.SellerReview};
\item \texttt{models.ItemReview};
\item \texttt{models.Tree};
\item \texttt{models.Treebank};
\item \texttt{models.Genre};
\item \texttt{models.GenreLink};
\item \texttt{models.Actor};
\item \texttt{models.ActorLink};
\item \texttt{models.Director};
\item \texttt{models.DirectorLink};
\item \texttt{models.Film};
\item \texttt{models.FilmReviewAuthor};
\item \texttt{models.FilmReview}.
\end{itemize}

Класс \texttt{models.Item} представляет товар интернет магазина. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и наименование товара. Далее поля \texttt{cost} типа \texttt{sqlalchemy.Integer}, \texttt{rating} типа \texttt{sqlalchemy.Integer}, \texttt{state} типа \texttt{sqlalchemy.String}, \texttt{number} типа \texttt{sqlalchemy.Integer} и \texttt{sold} типа \texttt{sqlalchemy.Integer} хранят соответственно цену товара, рейтинг товара, состояние, количество товара в наличии и товара продано. Затем два поля \texttt{seller} типа \texttt{models.Seller} и \texttt{store} типа \texttt{models.Store} хранят ссылки на объекты продавца и магазина соответственно.

Класс \texttt{models.Store} представляет магазин интернет площадки. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название магазина. Так как магазин является лишь композицей для товаров, то товар может существовать без магазина, верно и обратное --- магазин может существовать без товара. Поэтому между классами товара \texttt{models.Item} и магазина \texttt{models.Store} образована свзяь типа агрегация, как это видно из диаграммы классов на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Achievement} представляет собой достижение магазина интернет площадки. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и название достижения.

Так как каждый магазин может иметь произвольное количество достижений, а каждое достижение может принадлежать нескольким магазинам, то между достижением и магазином связь много ко многим. Поэтому класс \texttt{models.AchievementLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом достижения и объектом магазина. Класс \texttt{models.AchievementLink} имеет публичное поле \texttt{achievement} типа \texttt{models.Achievement}, которое хранит ссылку на объект класса достижения. При удалении достижения свзяь между достижением и магазином так же должна разрушаться. Поэтому из класса ассоциативной таблицы \texttt{models.AchievementLink} исходит связь вида композиция в сторону класса достижения \texttt{models.Achievement}, что отображено на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1. Также \texttt{models.AchievementLink} хранит ссылку на объект магазина в публичном поле \texttt{store} типа \texttt{models.Store}. Так как при разрушении объекта магазина связь между магазином и достижением теряет смысл, то объект типа \texttt{models.AchievementLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.AchievementLink} исходит связь типа композиции в сторону класса магазина \texttt{Store}. Данные композиция отражена на диаграмме классов на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Seller} представляет собой описание продавца интернет магазина. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и логин продавца. Так же он имеет поля \texttt{description\_rating} типа \texttt{sqlalchemy.Integer}, \texttt{communication\_rating} типа \texttt{sqlalchemy.Integer}, \texttt{timing\_rating} типа \texttt{sqlalchemy.Integer} и \texttt{delivery\_cost\_rating} типа \texttt{sqlalchemy.Integer} которые хранят соответственно рейтинги продавца по следующим параметрам:
\begin{itemize}
\item рейтинг точности составления описания;
\item рейтинг общения с продавцом;
\item рейтинг своевременности доставки;
\item рейтинг удовлетворенностью ценой доставки.
\end{itemize}
При удалении товара объект продавца должен быть сохранен. А при удалении объекта продавца объект товара должен быть сохранен. Но так как объект товара имеет ссылку на продавца, то от класса \texttt{models.Item} направлена связь типа агрегация в сторону класса \texttt{models.Seller}. Связь отражена на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1. Также, класс \texttt{models.Store} связан с классом \texttt{models.Seller} отношением типа ассоциация, из-за того, что между ними может существовать косвенная связь, вплоть до того, что продавец и магазин будут отражать один и тот же объект. То есть продавец может оказаться частью магазина в модели интернет площадки, а может быть и самостоятельным объектом.

Класс \texttt{models.User} представляет объект пользователя. Идентификатор объекта в базе данных и логин пользователя хранятся соответственно в полях \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{login} типа \texttt{sqlalchemy.String}. Публичные поля \texttt{addres} типа \texttt{sqlalchemy.String}, \texttt{country} типа \texttt{sqlalchemy.String}, \texttt{state} типа \texttt{sqlalchemy.String}, \texttt{rating} типа \texttt{sqlalchemy.Integer} и \texttt{birth\_date} типа \texttt{sqlalchemy.Date} хранят соответственно адрес доставки пользователя, страна, время последнего выхода в онлайн, рейтинг пользователя и дата рождения.

Класс \texttt{models.Genre} представляет жанр фильма на форуме о кино. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название жанра кино.

Класс \texttt{models.SellerReview} представляет обзор на продавца в интернет магазине. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{review\_text} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и текст отзыва на продавца. Оценка продавца пользователем хранится в публичном поле \texttt{seller\_grade} типа \texttt{sqlalchemy.Integer}. Автор отзыва указан ссылкой на объект пользователя в публичном поле \texttt{user} типа \texttt{models.User}. Так как при удалении пользователя, обзор теряет силу и значимость, то необходимо удалять вслед за этим и объект обзора на продавца в интернет магазине. Таким образом от класса обзора \texttt{models.SellerReview} направлена связь вида композиция в сторону класса \texttt{models.User}. Композиция отражена в диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1. В поле \texttt{seller} типа \texttt{models.Seller} хранится ссылка на объект продавца интернет магазина, описанного в данном объекте отзыва. При удалении объекта продавца, который описывает текущий объект отзыва на продавца, отзыв на продавца так же должен быть удален. Следовательно, от класса отзыва \texttt{models.SellerReview} направлена связь типа композиция в сторону класса продавца \texttt{models.Seller}. Данная композиция также отражена на диаграмме классов на чертеже ГУИР.400201.009.РР.1. Также класс \texttt{models.SellerReview} хранит ссылку на объект синтаксического дерева, в публичном поле \texttt{tree} типа \texttt{models.Tree}. Так как объект синтаксического дерева хранит текст отзыва на продавца в интернет магазине в формате синтаксического дерева, то при удалении объекта отзыва на продавца, объект синтаксического дерева должен быть так же удален. Значит, от класса продавца \texttt{models.Seller} направлена связь типа композиция в сторону класса обзора \texttt{models.SellerReview}. Данная связь также отражена в диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1.

Так как каждый фильм может принадлежать к произвольному количеству жанров, а каждый жанр может быть присвоен нескольким фильмам, то между жанром и фильмом связь много ко многим. Поэтому класс \texttt{models.GenreLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом жанра и объектом фильма. Класс \texttt{models.GenreLink} имеет публичное поле \texttt{genre} типа \texttt{models.Genre}, которое хранит ссылку на объект класса жанра кино на тематическом форуме. При удалении жанра свзяь между жанром и фильмом так же должна разрушаться. Поэтому из класса ассоциативной таблицы \texttt{models.GenreLink} исходит связь вида композиция в сторону класса жанра \texttt{models.Genre}. Данная связь отражена на диаграмме классов чертеже ГУИР.400201.009.РР.1. Также \texttt{models.GenreLink} хранит ссылку на объект фильма в публичном поле \texttt{film} типа \texttt{models.Film}. Так как при разрушении объекта фильма связь между фильмом и жанром фильма теряет смысл, то объект типа \texttt{models.GenreLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.GenreLink} исходит связь типа композиции в сторону класса фильма \texttt{models.Film}. Данная связь также отражена диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Film} представляет собой объект фильма на тематическом форуме. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{title} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и название фильма. Информация о дате выхода фильма в прокат, страна производства фильма и бдюжет хранится соответственно в полях: \texttt{year} типа \texttt{sqlalchemy.Date}, \texttt{country} типа \texttt{sqlalchemy.String} и \texttt{budget} типа \texttt{sqlalchemy.Integer}.

Класс \texttt{models.Filmreviewauthor} представляет автора отзыва на фильм на тематическом форуме. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и имя автора отзыва на фильм на тематическом форуме.

Класс \texttt{models.FilmReview} представляет обзор на фильм на таматическом форуме. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и текст отзыва на фильм. Оценка фильма пользователем хранится в публичном поле \texttt{film\_grade} типа \texttt{sqlalchemy.Integer}. Автор отзыва указан ссылкой на объект автора в публичном поле \texttt{authpr} типа \texttt{models.FilmReviewAuthor}. Так как обзор должен иметь автора, то при удалении автора необходимо удалять вслед за этим и объект обзора на фильм. Таким образом от класса \texttt{models.FilmReview} направлена связь вида композиция в сторону класса \texttt{models.Filmreviewauthor}, что видно из диаграммы классов на чертеже ГУИР.400201.009.РР.1. В поле \texttt{film} типа \texttt{models.Film} хранится ссылка на объект фильма, описанного в данном объекте отзыва. При удалении объекта фильма, который описывает текущий объект отзыва на фильм, то отзыв на фильм так же должен быть удален. Следовательно, от класса \texttt{models.ItemFilm} направлена связь типа композиция в сторону класса \texttt{models.Film}. Данная композиция изображена на диаграмме классов на чертеже ГУИР.400201.009.РР.1. Также \texttt{models.FilmReview} хранит ссылку на объект синтаксического дерева, в публичном поле \texttt{tree} типа \texttt{models.Tree}. Так как объект синтаксического дерева хранит текст отзыва на фильм в формате синтаксического дерева, то при удалении объекта отзыва на фильм, объект синтаксического дерева должен быть так же удален. Значит, от класса \texttt{models.Tree} направлена связь типа композиция в сторону класса \texttt{models.FilmReview}. Данная связь отражена на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Actor} представляет актера кино на тематическом форуме. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и имя актера.

Так как в каждом фильме может сниматься произвольное количество актеров, а каждый актер может играть роли в произвольном количестве фильмов, то между актером и фильмом связь много ко многим. Поэтому класс \texttt{models.ActorLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом фильма и объектом актера. Класс \texttt{models.ActorLink} имеет публичное поле \texttt{actor} типа \texttt{models.Actor}, которое хранит ссылку на объект класса актера кино на тематическом форуме. При удалении актера свзяь между актером и фильмом так же должна разрушаться. Поэтому из класса ассоциативной таблицы \texttt{models.ActorLink} исходит связь вида композиция в сторону класса актера \texttt{models.Actor}. Данная связь отражена на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1. Также \texttt{models.ActorLink} хранит ссылку на объект фильма в публичном поле \texttt{film} типа \texttt{models.Film}. Так как при разрушении объекта фильма связь между фильмом и актером теряет смысл, то объект типа \texttt{models.ActorLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.ActorLink} исходит связь типа композиции в сторону класса фильма \texttt{models.Film}. Данная связь также отражена на диаграмме классов, изображенноей на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Treebank} представляет собой отображение набора синтаксических деревьев, хранящихся в базе данных. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название набора данных. Название набора данных выбирается одно из ряда:
\begin{itemize}
\item \texttt{sst\_dev};
\item \texttt{sst\_test};
\item \texttt{sst\_train};
\item \texttt{film\_reviews};
\item \texttt{item\_reviews};
\item \texttt{seller\_reviews}.
\end{itemize}
Код \texttt{sst} обозначает Stanford Sentiment Treebank --- Стенфордский набор данных. Так же в базе хранятся наборы данных созданные из обзоров на фильмы, полученные из тематического форума --- \texttt{film\_reviews}, из онлайн магазина --- \texttt{item\_reviews}, и также обзоры на продавцов --- \texttt{seller\_reviews}.

Класс \texttt{models.ItemReview} представляет обзор на товар в интернет магазине. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{review\_text} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и текст отзыва на товар. Оценка товара пользователем хранится в публичном поле \texttt{item\_grade} типа \texttt{sqlalchemy.Integer}. Автор отзыва указан ссылкой на объект пользователя в публичном поле \texttt{user} типа \texttt{models.User}. Так как при удалении пользователя, обзор теряет силу и значимость, то необходимо удалять вслед за этим и объект обзора на товар. Таким образом от класса \texttt{models.ItemReview} направлена связь вида композиция в сторону класса \texttt{models.User}, что отображено на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1. В поле \texttt{item} типа \texttt{models.Item} хранится ссылка на объект товара, описанного в данном объекте отзыва. При удалении объекта товара, который описывает текущий объект отзыва на товар, отзыв на товар в интернет магазине так же должен быть удален. Следовательно, от класса \texttt{models.ItemReview} направлена связь типа композиция в сторону класса \texttt{models.Item}. Данная композиция изображена на диаграмме классов на чертеже ГУИР.400201.009.РР.1. Также класс \texttt{models.ItemReview} хранит ссылку на объект синтаксического дерева в публичном поле \texttt{tree} типа \texttt{models.Tree}. Так как объект синтаксического дерева хранит текст отзыва в формате синтаксического дерева, то при удалении объекта отзыва на товар в интернет магазине, объект синтаксического дерева должен быть так же удален. Значит, от класса \texttt{models.Tree} направлена связь типа композиция в сторону класса \texttt{models.ItemReview}. Данная композиция также отображена на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Director} представляет режиссера кино на тематическом форуме. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и имя режиссера.

Так как в каждом фильме может участвовать произвольное количество режиссеров, а каждый режиссер может снимать произвольное количество фильмов, то между режиссером и фильмом связь много ко многим. Поэтому класс \texttt{models.DiretorLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом фильма и объектом режиссера. Класс \texttt{models.DirectorLink} имеет публичное поле \texttt{director} типа \texttt{models.Director}, которое хранит ссылку на объект класса режиссера кино на тематическом форуме. При удалении режиссера свзяь между режиссером и фильмом так же должна разрушаться. Поэтому из класса ассоциативной таблицы \texttt{models.DirectorLink} исходит связь вида композиция в сторону класса режиссера \texttt{models.Director}. Данная связь отражена на диаграмме классов на чертеже ГУИР.400201.009.РР.1. Также \texttt{models.DirectorLink} хранит ссылку на объект фильма в публичном поле \texttt{film} типа \texttt{models.Film}. Так как при разрушении объекта фильма связь между фильмом и его режиссером теряет смысл, то объект типа \texttt{models.DirectorLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.DirectorLink} исходит связь типа композиции в сторону класса фильма \texttt{models.Film}. Данная композиция также отражена на диаграмме классов, изображенноей на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Tree} представляет объект синтаксического дерева. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{json} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и представление синтаксического дерева в формате JSON\@. Поле \texttt{treebank} типа \texttt{models.Treebank} хранит ссылку на объект набора данных. Так как синтаксическое дерево может быть независимым и не входить ни в один из наборов данных, но иимеет поле ссылки на \texttt{models.Treebank}, то между классами набора данных и синтаксического дерева создается связь вида агрегация направленная он \texttt{models.Tree} в сторону \texttt{models.Treebank}. Данная агрегация отображена на диаграмме классов на чертеже ГУИР.400201.009.РР.1.
\subsection{Модуль сбора статистики}
Модуль сбора статистики, описанный в downloader.py в виде класса Downloader, осуществляет сбор статистики с интернет ресурсов, и сохраняет её в базе данных. Для работы с базой класс имеет поля \texttt{session} типа \texttt{sqlalchemy.Session} и \texttt{db\_driver} типа \texttt{sqlalchemy.DbDriver}. В объекте \texttt{db\_driver} содержится информация о подключении к базе данных:
\begin{itemize}
\item база данных (MySQL\@ или PostgreSQL\@)
\item драйвер базы данных для \texttt{Python} (напрмер \texttt{oursql} или \texttt{pymysql})
\item адрес хоста базы;
\item имя базы;
\item логин;
\item пароль.
\end{itemize}
Далее он имеет конфигурируемые переменные \texttt{FILM\_TOKEN\_LEN} и \texttt{ITEM\_TOKEN\_LEN}, заданные глобально в модуле Python. Это стандартная практика для защиты конфигурации. Данные переменные задают количество скачиваемых объектов за один REST запрос для фильмов и товаров соответственно. В константах \texttt{STORE\_URL} и \texttt{FILM\_FORUM\_URL} хранятся URL целевых ресурсов. Массивы \texttt{item\_reviews}, \texttt{seller\_reviews} и \texttt{film\_reviews} хранят соответственно объекты реляционного отображения таблиц с отзывами.

Класс \texttt{Downloader} содежрит набор схожих методов:
\begin{itemize}
\item \texttt{get\_items};
\item \texttt{get\_film};
\item \texttt{get\_categories};
\item \texttt{get\_stores};
\item \texttt{get\_sellers};
\item \texttt{get\_achivements};
\item \texttt{get\_actors};
\item \texttt{get\_directors};
\item \texttt{get\_subcategories}.
\end{itemize}

Задача данных методов в том, чтобы преобразовать полученный от интернет ресурса GET ответ в формате JSON в объек объектно реляциоонного отображения, создав тем самым соответствующую запись в базе данных. Каждый из этих методов имеет константу, хранящую часть путь в URL адресе. Далее имеется переменная {\texttt{params}} типа \texttt{dict}, хранящая параметры REST запросов. Пример объявления \texttt{params} показан ниже:

\medskip
\begin{lstlisting}[style=Python]
  params = {'sortBy': 'recentlyCreated',
    'group': 'general',
    'page': 1,
    'pageSize': self.FILM_PAGE_SIZE}
\end{lstlisting}
\medskip

Переменная \texttt{response} типа хранит ответы на REST запросы. Так же множество различных локальных переменных введены для хранения промежуточных результатов преобразования из JSON в объект. Методы \texttt{save\_film\_info} и \texttt{save\_item\_info} формируют конечную транзацкию в базу данных.

Наконец, задача метода \texttt{get\_missing} проверить целостность данных в базе. Для этого используется схожий набор переменных: \texttt{params} и \texttt{response} для управления REST запросами. Для проверки целостности со стороны клиента используются массивы класса \texttt{item\_reviews}, \texttt{seller\_reviews} и \texttt{film\_reviews}.
\subsection{Модуль ячейки Tree LSTM}
Класс \texttt{cstlstm.ChildSumTreeLSTMCell} выделен в модуль ячейки Tree LSTM за счет его математической сложности. Класс имеет следующие поля:
\begin{itemize}
\item \texttt{unit\_number};
\item \texttt{forget\_bias};
\item \texttt{forget\_signals};
\item \texttt{iou\_signals};
\item \texttt{input\_transform}.
\end{itemize}
Для удобства вычилсений произведены приобразование рассчетов состояний нейронов в узле Child Sum Tree LSTM следующим образом:
\begin{gather}
  \label{eq:func:lstm:i}
  i_{jk} = \sigma(W^{(i)}\cdot{x_j} + U^{(i)}\cdot{\tilde{h_j}} + b^{(i)}) = \sigma({V^{(i)}\cdot{
      \begin{bmatrix}
        x_j\\
        h_j
      \end{bmatrix}} + b^{(i)}}),\\
  \label{eq:func:lstm:forget}
  f_{jk} = \sigma(W^{(f)}\cdot{x_j} + U^{(f)}\cdot{h_k} + b^{(f)}) = \sigma({V^{(f)}\cdot{
      \begin{bmatrix}
        x_j\\
        h_j
      \end{bmatrix}} + b^{(f)}}),\\
  \label{eq:func:lstm:o}
  o_{jk} = \sigma(W^{(o)}\cdot{x_j} + U^{(o)}\cdot{h_j} + b^{(o)}) = \sigma({V^{(o)}\cdot{
      \begin{bmatrix}
        x_j\\
        h_j
      \end{bmatrix}} + b^{(o)}}),\\
  \label{eq:func:lstm:u}
  u_{jk} = \sigma(W^{(u)}\cdot{x_j} + U^{(u)}\cdot{h_j} + b^{(u)}) = \sigma({V^{(u)}\cdot{
      \begin{bmatrix}
        x_j\\
        h_j
      \end{bmatrix}} + b^{(u)}}),\\
  \label{eq:func:lstm:transform}
  c_j = i_j\odot{u_j} + \sum_{k\in{C(j)}}f_{jk}\odot{c_k},
\end{gather}
\begin{explanationx}
\item [где]       $\begin{bmatrix}x_j\\h_j\end{bmatrix}$ --- конкатенация векторов $x_j$ и $h_j$;
\item $V$ --- это конкатенация матриц весов $W$ и $H$.
\end{explanationx}

Публичное поле \texttt{unit\_number} имеет тип \texttt{int}. Хранит количество нейронов скрытого слоя нейронной сети в архитектуре Child-Sum Tree LSTM\@. Далее, публичное поле \texttt{forget\_bias} типа \texttt{float} содержит $b^{(f)}$ применяющийся в формуле~\ref{eq:func:lstm:forget}. Публичное поле \texttt{forget\_signals} типа \texttt{keras.Layers.Dense} описывает само уравнение~\ref{eq:func:lstm:forget}. \texttt{keras.Layers.Dense} является реализацией базового слоя нейронной сети. В данном слое будут две обучаемые переменные: матрица весов и вектор сдвига. Они соответствуют членам формулы $W^{(f)}$, $U^{(f)}$ и $b^{(f)}$. Класс \texttt{keras.Layers.Dense} поддерживает автоматическое вычисление градиента и оптимизацию обучаемых переменных. Публичное поле \texttt{iou\_signals} типа \texttt{keras.Layers.Dense} выполняет схожую функцию для одновременного вычисления сигналов, описанных формулами~\ref{eq:func:lstm:i},~\ref{eq:func:lstm:o} и~\ref{eq:func:lstm:u}.

Последнее публичное поле \texttt{input\_transform} типа \texttt{keras.Layers.Dense} реализует~\ref{eq:func:lstm:transform}.

Код инициализации класса \texttt{cstlstm.ChildSumTreeLSTMCell} представлен в листинге ниже:

\medskip
\begin{lstlisting}[style=Python]
  super(ChildSumTreeLSTMCell, self).__init__()
  self.unit_number = unit_number
  self.forget_bias = forget_bias
  self.forget_signals = layers.Dense(unit_number, input_shape=(300 + unit_number,), kernel_regularizer=tf.keras.regularizers.l2(reg_factor))
  self.iou_signals = layers.Dense(unit_number * 3, kernel_regularizer=tf.keras.regularizers.l2(reg_factor))
  self.input_transform = layers.Dense(unit_number, kernel_regularizer=tf.keras.regularizers.l2(reg_factor))
\end{lstlisting}
\medskip

Как видно в листинге, полносвязные слои, такие как \texttt{forget\_signals}, \texttt{iou\_signals} и \texttt{input\_transform}, в качестве параметра конструктора получают также объект типа \texttt{keras.regularizers.l2}. Данный параметр задаст регуляризацию L2, для того чтобы смесить математическое ожидание ближе к верному предсказанию за счет увеличения дисперсии.

Класс \texttt{cstlstm.ChildSumTreeLSTMCell} имеет только один метод \texttt{call(self, inputs, *args, **kwargs)}. Это переопределенный метод класса \texttt{keras.Layers.Model}. Данный метод вызывается, когда проиходит обращение к объекту типа \texttt{keras.Layers.Model} в ходе выполнения графа обработки Tensorflow. Параметр \texttt{inputs} типа \texttt{tensorflow.Tensor} содержит входные данные в виде многомерного массива. Задача метода в том, чтобы обработать входной тензор согласно логике слоя Child-Sum Tree LSTM и затем вернуть результат в формате \texttt{tensorflow.Tensor}.

\subsection{Модуль анализатора}
В модуль анализатора включены следующие классы:
\begin{itemize}
\item \texttt{cstlstm.ChildSumTreeLSTMClassifier};
\item \texttt{train.Train};
\item \texttt{train.Treebank};
\item \texttt{inference.Inference}.
\end{itemize}
Их задача в том, чтобы обучать модель Child-Sum Tree LSTM, и делать предсказания тональностей для некоторых наборов данных.

Класс \texttt{cstlstm.ChildSumTreeLSTMClassifier} реализует архитектуру Child-Sum Tree LSTM\@. Данный класс обладает следующими публичными полями:
\begin{itemize}
\item \texttt{embed};
\item \texttt{projection};
\item \texttt{encoder};
\item \texttt{output\_layer};
\item \texttt{dropout};
\item \texttt{reg\_factor};
\item \texttt{loss};
\item \texttt{result};
\item \texttt{fine};
\item \texttt{binary};
\item \texttt{root\_fine};
\item \texttt{root\_binary}.
\end{itemize}

Публичное поле \texttt{embed} типа \texttt{tensorflow.Tensor} представляет собой матрицу встраивания слов.

Tensorflow --- это фреймворк, задача которого в, общем случае, упростить реализацию каких-то операций линейной алгебры, для выполнения их на графических процессорах, или тенсорных процессорах. Центральный процессор, и графический процессор или тенсорный процессор имеют раздельную память. Операции пересылки данных из памяти одного устройства в память другого довольно затратные и значительно замедляют результирующую производительность. Хотя в подавляющем большинстве случаев обращаются к выполнению вычислений на графических или тенсорных процессорах именно с целью повышения производительности алгоритма в сравнении с производительностью его выполнения на центральном процессоре. Поэтому, с целью сократить количество пересылок между устройствами памяти, фреймворки, созданные для реализации алгоритмов на графических процессорах, такие как Tensorflow или Theano, строят граф алгоритма, где четко заданы потоки перемещения и обработки данных.

Класс \texttt{tensorflow.Tensor} --- это бызовый класс Tensorflow, который представляет вывод какой-либо операции в графе выполнения алгоритма в Tensorflow. Объект типа \texttt{tenosorflow.Tensor} --- это символьный контроллер вывода операции, он не содержит самого численного результата выполнения операции. Но вместо этого он предоставляет возможность вычислить значение с помощью \texttt{tensorflow.Session}. У класса \texttt{tensorflow.Tenser} два основных предназначения:
\begin{itemize}
\item Объект \texttt{tensorflow.Tensor} может быть передан другой операции. Это создаст связь между операциями в графе выполнения Tensorflow.
\item После того как граф был запущен в \texttt{tensorflow.Session}, значение результата операции может быть получено с помощью \texttt{tensorflow.Session.run}. \texttt{tensorflow.Tensor.eval()} --- это сокращение для \texttt{tensorflow.Session.run()}
\end{itemize}

Публичное поле \texttt{embed} типа \texttt{tensorflow.Tensor} хранит константный двумерный массив, в каждой строке которой хранится некоторый вектор из модели GloVe.

Встраивание слов производится с помощью модели GloVe, которая обучена для кодировки семантики слов на основе контекста их использования. Однако, чтобы сделать модель более применимой для задачи классификации тональностей, её возможно дообучить. Продолжать тренировать модель GloVe одновременно с моделью Tree LSTM --- это крайне неэффективное решение, так как хотя бы сама модель в сжатом виде занимает 5 гигабайт дискового пространства. А вычисление градиента и последующая оптимизация такого количества векторов займет невероятно много времени. Поэтому оригинальная модель GloVe фильтруется. В ней оставляют только слова, использующиеся в тренировочном наборе данных. Отфильтрованная под Стенфордский набор синтаксических деревьев модель GloVe занимает уже 80 мегабайт дискового простанства. Затем, чтобы дообучать векторы из отфильтрованной модели GloVe, вводится ещё один слой нейронной сети. Это полносвязный слой, имеющий такое же количество нейронов, как и вектор GloVe. Таким образом, размерность векторов меняться не будет, однако их значение будет  оптимизироваться одновременно с параметрами всей архитектуры Child-Sum Tree LSTM во время процесса обучения. Задачу данного полносвязного слоя и выполняет публичное поле \texttt{projection} типа \texttt{keras.Layers.Dense} класса \texttt{cstlstm.ChildSumTreeLSTMClassifier}.

Конструктор класса \texttt{cstlstm.ChildSumTreeLSTMClassifier} представлен ниже:
\medskip
\begin{lstlisting}[style=Python]
  def __init__(self, embed, unit_numb=150, class_numb=5, reg_factor=0.0001, keep_prob=0.5):
    super(ChildSumTreeLSTMClassifier, self).__init__()
    self.embed = tf.constant(embed)
    self.projection = layers.Dense(self.embed.shape[1], kernel_regularizer=tf.keras.regularizers.l2(reg_factor))
    self.encoder = ChildSumTreeLSTMCell(unit_numb, reg_factor)
    self.output_layer = layers.Dense(class_numb, kernel_regularizer=tf.keras.regularizers.l2(reg_factor))
    self.dropout = layers.Dropout(keep_prob)
    self.reg_factor = reg_factor
    self.loss = 0
    self.result = []
    self.fine = tfe.metrics.Accuracy()
    self.binary = tfe.metrics.Accuracy()
    self.root_fine = tfe.metrics.Accuracy()
    self.root_binary = tfe.metrics.Accuracy()
    super(ChildSumTreeLSTMCell, self).__init__()
    self.unit_number = unit_number
    self.forget_bias = forget_bias
    self.forget_signals = layers.Dense(unit_number, input_shape=(300 + unit_number,), kernel_regularizer=tf.keras.regularizers.l2(reg_factor))
    self.iou_signals = layers.Dense(unit_number * 3, kernel_regularizer=tf.keras.regularizers.l2(reg_factor))
    self.input_transform = layers.Dense(unit_number, kernel_regularizer=tf.keras.regularizers.l2(reg_factor))
\end{lstlisting}
\medskip

Публичное поле \texttt{encoder} типа \texttt{cstlstm.ChildSumTreeLSTMCell} представляет ячейку Child-Sum Tree LSTM, которая встраивается в общий поток выполнения графа Tensorflow.

Далее, публичное поле \texttt{output\_layer} типа \texttt{keras.Layers.Dense}, представляет собой логическую регрессию. Логическая регрессия применяется после того, как предложение представлено в виде плотного вектора. Логическая регрессия обучается одновременно с моделью Child-Sum Tree LSTM\@. Логическая регрессия регуляризуется методом L2.

Публичное поле \texttt{dropout} типа \texttt{keras.Layers.Dropout} представляет реализацию техники исключения. Суть данного метода в том, что во время обучения нейронной сети отключаются случайным образом некоторые нейроны и не учавствуют в итерации обучения на некотором наборе данных. Это позволяет избежать переобучения модели, точно как и регуляризация параметров.

Публичное поле \texttt{reg\_factor} содержит коэффициент регуляризации. Являясь одним из гиперпараметров архитектуры, \texttt{reg\_factor} позволяет балансировать значимостью в процессе противодействия переобучению методов регуляризации и исключения.

Публичное поле \texttt{result} типа \texttt{int[]} является массивом целых чисел, и хранит результаты предсказаний тональности в порядке развертки синтаксического дерева. То есть во время рекурсивного обхода дерева поиском в глубину, на каждой итерациии будет производится предсказание тональности для текущего узла. Результат каждого предсказания будет сохраняться в массив \texttt{result} в порядке обхода. Затем, эта последовательность будет восстанавливаться, параллельно создавая деверо визуализации.

Следующие четыре поля содержат метрики. Метрики бывают двух типов относительно того, когда они считаются:
\begin{itemize}
\item fine-graded --- предсказание делается для пяти классов;
\item бинарное --- предсказание делается только для двух классов.
\end{itemize}

Так же метрики делятся на два типа относительно момента их вычисления:
\begin{itemize}
\item корневые метрики --- вычисляются для всего дерева, только в момент предсказания для корня синтаксического дерева;
\item узловые метрики --- вычисляются на всех итерациях обработки дерева.
\end{itemize}

Таким образом комбинация этих двух свойств дают четыре метрики:
\begin{itemize}
\item \texttt{fine} --- fine-graded узловая;
\item \texttt{binary} --- бинарная узловая;
\item \texttt{root\_fine} --- fine-graded корневая;
\item \texttt{root\_binary} бинарная корневая.
\end{itemize}

Каждое из этих полей имеет тип \texttt{tenosorflow.metrics.Accuracy}. Данный класс аккумулирует предсказания и тренировочные данные, чтобы затем высчитать точность модели на некотором наборе данных.

Публичный метод \texttt{reset\_metrics(self)} класса \texttt{cstlstm.ChildSumTreeLSTMClassifier} необходим для того, чтобы сбрасывать результаты прошлых итераций обработки набора данных. Данный метод возвращает \texttt{None}, то есть является процедурой.

Публичный метод \texttt{model\_variables(self)} класса \texttt{cstlstm.ChildSumTreeLSTMClassifier} возвращает список обучаемых параметров, которые будут изменяться в ходе оптимизации. Однако, из-за механизма дообучения встраивания слов, скорость обучения проекции GloVe на порядок меньше скорости обучения всей остальной модели. По этой причине метод \texttt{model\_variables(self)} возвращает список обучаемых параметров за исключением параметров проекции векторов из модели GloVe.

Публичный метод \texttt{embed\_variables(self)} класса \texttt{cstlstm.ChildSumTreeLSTMClassifier} возвращает список обучаемых переменных слоя проекции векторов из модели GloVe. Данные списки параметров, возвращаемые методами \texttt{embed\_variables(self)} и \texttt{model\_variables(self)} передаются в функции вычисления градиента, чтобы впоследствии оптимизировать эти параметры в соответствии с функцией потерь.

Публичный метод \texttt{call(self, inputs, training=None, *args, **kwargs)} класса \texttt{cstlstm.ChildSumTreeLSTMClassifier} --- это переопределенный метод класса \texttt{keras.Layers.Model}. Данный метод вызывается, когда проиходит обращение к объекту типа \texttt{keras.Layers.Model} в ходе выполнения графа обработки Tensorflow. Параметр \texttt{inputs} типа \texttt{tensorflow.Tensor} содержит входные данные в виде многомерного массива. В данном случае \texttt{inputs} --- это тензор строк, где в формате JSON хранятся синтаксические деревья. Параметр \texttt{training} типа \texttt{bool} содержит информацию о том, запущена ли модель в каком из двух режимов запущена модель: предсказание или обучение.

Публичный метод \texttt{eval\_tree(self, tree, is\_root=True)} класса \texttt{cstlstm.ChildSumTreeLSTMClassifier} --- это метод рекурсивного поиска в глубину, для обработки синтаксического дерева. Параметр \texttt{tree} типа \texttt{list} содержит входное синтаксическое дерево зависимостей. Параметр \texttt{is\_root} хранит флаг, отвечающий за то, находится ли сейчас рекрсия в корневом узле синтаксического дерева зависимостей или нет. Этот параметр важен для правильного подсчета метрик.

Публичный метод \texttt{checkpoint(self)} класса \texttt{cstlstm.ChildSumTreeLSTMClassifier} возвращает объект типа \texttt{tensorflow.contrib.eager.Checkpointable}, который сериализует и десериализует модель. % Здесь можно ещё много всего соченить

Класс \texttt{train.Treebank} контролируюет прогресс обработки некоторого набора данных. При создании объекта типа \texttt{train.Treebank} будет выгружен набор данных из базы данных или из файла. Затем, во время итерации по набору данных можно будет изображать прогресс выполнения с помощью вызова метода \texttt{print\_progress\_bar}. Данный метод будет рассчитывать текущий прогресс основываясь на публичном поле класса \texttt{train.Treebank} \texttt{size}, который хранит размер всего набора данных. Это необходимо, так как инструменты контроля набора данных в Tensorflow не поддерживают такой возможности.