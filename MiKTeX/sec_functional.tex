\section{ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ}
\label{sec:functional}
Ниже будет описана работа разрабатываемого проекта и представлена информация о структуре программного продукта.

В проекте использован объектно-ориентированный подход, поэтому код проекта разделён на классы. Каждый класс выполняет свою уникальную функцию или расширяет функционал, предоставляемый фреймворком и сторонними библиотеками. Для взаимодействия всех классов и для интеграции проекта с дополнительными библиотеками используются файлы конфигурации.

Так же, так как сбор статистики и анализ тональностей --- независимые друг от друга задачи, то проект представляет собой два приложения, управляемые внешним скриптом.
\subsection{Структура проекта}
Разрабатываемый проект разделен на несколько каталогов:
\begin{itemize}
\item data\_gather --- хранит код сбора данных;
\item sentiment --- хранит код анализатора тональностей;
\item data --- хранит временные данные программы и входные данные;
\item javascript --- хранит код модуля визуализации;
\item treebank --- хранит код скриптов предобработки наборов данных.
\end{itemize}
\subsection{Структура базы данных}
Модель данных, иллюстрирующая таблицы базы данных и связи между ними приведена на чертеже ГУИР.400201.009 РР.3. В качестве базы данных была использована MySQL\@. Как видно из чертежа, для реализации связей один ко многим были использованы удаленные ключи, а для реализации связей много ко многим были созданы ассоциативные таблицы.
\subsection{Объектно-реляционное отображение}
В Python существует возможность не обращаться на прямую к базе данных. Это можно сделать при помощи \texttt{Sqlalchemy} --- инструмента объектно-реляционного отображения. \texttt{Sqlalchemy} предоставляет удобный функционал для работы с базами данных. В программной модели создается класс, соответствующий какой-то таблице из модели данных, и наследуется от класса \texttt{sqlalchemy.Model}. Используя магическое поле \texttt{\_\_tablename\_\_} указывается таблица, которой соответствует данный класс. Затем задаются поля класса, соответствующие столбцам таблицы базы данных, инстанцированные от класса \texttt{sqlalchemy.Column}. Так же указывается тип данных, который столбец имеет в базе данных. Затем описываются отношения с другими таблицами. Для этого предназначен модуль \texttt{sqlalchemy.orm}. С помощью функции \texttt{relationship} данного модуля можно задать простую связь, соответствующую удаленному ключу в базе данных. Существуют так же инструменты для реализации более сложных видов связей, вроде ассоциативных таблиц. Однако, инструмент ассоциативных таблиц не был использован в объектно-реляционном отображении в данном проекте, несмотря на то что данные таблицы широко используются в проекте для реализации связей вида много ко многим.

Пример объектно-реляционного отображения таблицы \texttt{item} показан ниже:

\medskip
\begin{lstlisting}[style=Python]
class Item(Base, DeclarativeBase):
    """The model for Item data"""
    __tablename__ = "item"

    id = sa.Column(sa.Integer, primary_key=True)
    name = sa.Column(VARCHAR(100, charset='utf8'), unique=True)
    cost = sa.Column(sa.Integer, primary_key=True)
    rating = sa.Column(sa.Integer, primary_key=True)
    state = sa.Column(VARCHAR(100, charset='utf8'), unique=True)
    number = sa.Column(sa.Integer, primary_key=True)
    sold = sa.Column(sa.Integer, primary_key=True)

    seller = orm.relationship("Seller", back_populates="items")
    store = orm.relationship("Store", back_populates="items")
\end{lstlisting}
\medskip

Как видно из приведенной на чертеже ГУИР.400201.009 РР.1 диаграммы классов, все таблицы модели данных имеют соответствующий класс в программной модели.

Класс \texttt{models.Category} представляет категорию товаров онлайн магазина. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название категории.

Класс \texttt{models.ItemSubCategory} представляет подкатегорию товара в онлайн магазине. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer}, \texttt{name} типа \texttt{sqlalchemy.String} и \texttt{category} типа \texttt{models.Category} хранят соответственно идентификатор в базе данных, название подкатегории и сслыку на объект категории, к которой данная подкатегория принадлежит. Так как подкатегория --- это составная часть категории, то при удалении объекта категории должен удаляться и объект подкатегории, на который ссылается объект категории, то между классами \texttt{models.ItemSubCategory} и \texttt{models.Category} устанавливается связь типа композиции, направленная от подкатегории к категории, как видно из приведенной на чертеже ГУИР.400201.009 РР.1 диаграммы классов.

Класс \texttt{models.CategoryLink} представляет ассоциативную таблицу для связи товара с его подкатегорией. Так как каждый товар может состоять в произвольном количестве подкатегорий, а подкатегория может содержать произвольное количество товаров, то между ними связь вида много ко многим. Таким образом, каждый объект класса данной ассоциативной таблицы представляет связь между объектом подкатегории и объектом товара. Класс \texttt{models.CategoryLink} имеет публичное поле \texttt{sub\_category} типа \texttt{models.ItemSubCategory}, которое хранит ссылку на объект класса подкатегории. При удалении подкатегории свзяь так же должна разрушаться. Поэтому из класса ассоциативной таблицы \texttt{models.CategoryLink} исходит связь вида композиция в сторону класса подкатегории \texttt{models.ItemSubCategory}, что видно из диаграммы классов на чертеже ГУИР.400201.009.РР1.1. Также \texttt{models.CategoryLink} хранит ссылку на объект товара в публичном поле \texttt{item} типа \texttt{models.Item}. Так как при разрушении объекта товара связь между товаром и подкатегорией теряет смысл, то объект типа \texttt{models.CategoryLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.CategoryLink} исходит связь типа композиции в сторону класса товара \texttt{Item}. Данная композиция отражена на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1.

Следующие классы являются объектно-реляционными отображениями:
\begin{itemize}
\item \texttt{models.Category};
\item \texttt{models.ItemSubCategory};
\item \texttt{models.CategoryLink};
\item \texttt{models.Item};
\item \texttt{models.Store};
\item \texttt{models.AchievementLink};
\item \texttt{models.Achievement};
\item \texttt{models.Seller};
\item \texttt{models.User};
\item \texttt{models.SellerReview};
\item \texttt{models.ItemReview};
\item \texttt{models.Tree};
\item \texttt{models.Treebank};
\item \texttt{models.Genre};
\item \texttt{models.GenreLink};
\item \texttt{models.Actor};
\item \texttt{models.ActorLink};
\item \texttt{models.Director};
\item \texttt{models.DirectorLink};
\item \texttt{models.Film};
\item \texttt{models.FilmReviewAuthor};
\item \texttt{models.FilmReview}.
\end{itemize}

Класс \texttt{models.Item} представляет товар интернет магазина. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и наименование товара. Далее поля \texttt{cost} типа \texttt{sqlalchemy.Integer}, \texttt{rating} типа \texttt{sqlalchemy.Integer}, \texttt{state} типа \texttt{sqlalchemy.String}, \texttt{number} типа \texttt{sqlalchemy.Integer} и \texttt{sold} типа \texttt{sqlalchemy.Integer} хранят соответственно цену товара, рейтинг товара, состояние, количество товара в наличии и товара продано. Затем два поля \texttt{seller} типа \texttt{models.Seller} и \texttt{store} типа \texttt{models.Store} хранят ссылки на объекты продавца и магазина соответственно.

Класс \texttt{models.Store} представляет магазин интернет площадки. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название магазина. Так как магазин является лишь композицей для товаров, то товар может существовать без магазина, верно и обратное --- магазин может существовать без товара. Поэтому между классами товара \texttt{models.Item} и магазина \texttt{models.Store} образована свзяь типа агрегация, как это видно из диаграммы классов на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Achievement} представляет собой достижение магазина интернет площадки. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и название достижения.

Так как каждый магазин может иметь произвольное количество достижений, а каждое достижение может принадлежать нескольким магазинам, то между достижением и магазином связь много ко многим. Поэтому класс \texttt{models.AchievementLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом достижения и объектом магазина. Класс \texttt{models.AchievementLink} имеет публичное поле \texttt{achievement} типа \texttt{models.Achievement}, которое хранит ссылку на объект класса достижения. При удалении достижения свзяь между достижением и магазином так же должна разрушаться. Поэтому из класса ассоциативной таблицы \texttt{models.AchievementLink} исходит связь вида композиция в сторону класса достижения \texttt{models.Achievement}, что отображено на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1. Также \texttt{models.AchievementLink} хранит ссылку на объект магазина в публичном поле \texttt{store} типа \texttt{models.Store}. Так как при разрушении объекта магазина связь между магазином и достижением теряет смысл, то объект типа \texttt{models.AchievementLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.AchievementLink} исходит связь типа композиции в сторону класса магазина \texttt{Store}. Данные композиция отражена на диаграмме классов на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Seller} представляет собой описание продавца интернет магазина. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и логин продавца. Так же он имеет поля \texttt{description\_rating} типа \texttt{sqlalchemy.Integer}, \texttt{communication\_rating} типа \texttt{sqlalchemy.Integer}, \texttt{timing\_rating} типа \texttt{sqlalchemy.Integer} и \texttt{delivery\_cost\_rating} типа \texttt{sqlalchemy.Integer} которые хранят соответственно рейтинги продавца по следующим параметрам:
\begin{itemize}
\item рейтинг точности составления описания;
\item рейтинг общения с продавцом;
\item рейтинг своевременности доставки;
\item рейтинг удовлетворенностью ценой доставки.
\end{itemize}
При удалении товара объект продавца должен быть сохранен. А при удалении объекта продавца объект товара должен быть сохранен. Но так как объект товара имеет ссылку на продавца, то от класса \texttt{models.Item} направлена связь типа агрегация в сторону класса \texttt{models.Seller}. Связь отражена на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1. Также, класс \texttt{models.Store} связан с классом \texttt{models.Seller} отношением типа ассоциация, из-за того, что между ними может существовать косвенная связь, вплоть до того, что продавец и магазин будут отражать один и тот же объект. То есть продавец может оказаться частью магазина в модели интернет площадки, а может быть и самостоятельным объектом.

Класс \texttt{models.User} представляет объект пользователя. Идентификатор объекта в базе данных и логин пользователя хранятся соответственно в полях \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{login} типа \texttt{sqlalchemy.String}. Публичные поля \texttt{addres} типа \texttt{sqlalchemy.String}, \texttt{country} типа \texttt{sqlalchemy.String}, \texttt{state} типа \texttt{sqlalchemy.String}, \texttt{rating} типа \texttt{sqlalchemy.Integer} и \texttt{birth\_date} типа \texttt{sqlalchemy.Date} хранят соответственно адрес доставки пользователя, страна, время последнего выхода в онлайн, рейтинг пользователя и дата рождения.

Класс \texttt{models.Genre} представляет жанр фильма на форуме о кино. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название жанра кино.

Класс \texttt{models.SellerReview} представляет обзор на продавца в интернет магазине. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{review\_text} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и текст отзыва на продавца. Оценка продавца пользователем хранится в публичном поле \texttt{seller\_grade} типа \texttt{sqlalchemy.Integer}. Автор отзыва указан ссылкой на объект пользователя в публичном поле \texttt{user} типа \texttt{models.User}. Так как при удалении пользователя, обзор теряет силу и значимость, то необходимо удалять вслед за этим и объект обзора на продавца в интернет магазине. Таким образом от класса обзора \texttt{models.SellerReview} направлена связь вида композиция в сторону класса \texttt{models.User}. Композиция отражена в диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1. В поле \texttt{seller} типа \texttt{models.Seller} хранится ссылка на объект продавца интернет магазина, описанного в данном объекте отзыва. При удалении объекта продавца, который описывает текущий объект отзыва на продавца, отзыв на продавца так же должен быть удален. Следовательно, от класса отзыва \texttt{models.SellerReview} направлена связь типа композиция в сторону класса продавца \texttt{models.Seller}. Данная композиция также отражена на диаграмме классов на чертеже ГУИР.400201.009.РР.1. Также класс \texttt{models.SellerReview} хранит ссылку на объект синтаксического дерева, в публичном поле \texttt{tree} типа \texttt{models.Tree}. Так как объект синтаксического дерева хранит текст отзыва на продавца в интернет магазине в формате синтаксического дерева, то при удалении объекта отзыва на продавца, объект синтаксического дерева должен быть так же удален. Значит, от класса продавца \texttt{models.Seller} направлена связь типа композиция в сторону класса обзора \texttt{models.SellerReview}. Данная связь также отражена в диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1.

Так как каждый фильм может принадлежать к произвольному количеству жанров, а каждый жанр может быть присвоен нескольким фильмам, то между жанром и фильмом связь много ко многим. Поэтому класс \texttt{models.GenreLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом жанра и объектом фильма. Класс \texttt{models.GenreLink} имеет публичное поле \texttt{genre} типа \texttt{models.Genre}, которое хранит ссылку на объект класса жанра кино на тематическом форуме. При удалении жанра свзяь между жанром и фильмом так же должна разрушаться. Поэтому из класса ассоциативной таблицы \texttt{models.GenreLink} исходит связь вида композиция в сторону класса жанра \texttt{models.Genre}. Данная связь отражена на диаграмме классов чертеже ГУИР.400201.009.РР.1. Также \texttt{models.GenreLink} хранит ссылку на объект фильма в публичном поле \texttt{film} типа \texttt{models.Film}. Так как при разрушении объекта фильма связь между фильмом и жанром фильма теряет смысл, то объект типа \texttt{models.GenreLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.GenreLink} исходит связь типа композиции в сторону класса фильма \texttt{models.Film}. Данная связь также отражена диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Film} представляет собой объект фильма на тематическом форуме. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{title} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и название фильма. Информация о дате выхода фильма в прокат, страна производства фильма и бдюжет хранится соответственно в полях: \texttt{year} типа \texttt{sqlalchemy.Date}, \texttt{country} типа \texttt{sqlalchemy.String} и \texttt{budget} типа \texttt{sqlalchemy.Integer}.

Класс \texttt{models.Filmreviewauthor} представляет автора отзыва на фильм на тематическом форуме. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и имя автора отзыва на фильм на тематическом форуме.

Класс \texttt{models.FilmReview} представляет обзор на фильм на таматическом форуме. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и текст отзыва на фильм. Оценка фильма пользователем хранится в публичном поле \texttt{film\_grade} типа \texttt{sqlalchemy.Integer}. Автор отзыва указан ссылкой на объект автора в публичном поле \texttt{authpr} типа \texttt{models.FilmReviewAuthor}. Так как обзор должен иметь автора, то при удалении автора необходимо удалять вслед за этим и объект обзора на фильм. Таким образом от класса \texttt{models.FilmReview} направлена связь вида композиция в сторону класса \texttt{models.Filmreviewauthor}, что видно из диаграммы классов на чертеже ГУИР.400201.009.РР.1. В поле \texttt{film} типа \texttt{models.Film} хранится ссылка на объект фильма, описанного в данном объекте отзыва. При удалении объекта фильма, который описывает текущий объект отзыва на фильм, то отзыв на фильм так же должен быть удален. Следовательно, от класса \texttt{models.ItemFilm} направлена связь типа композиция в сторону класса \texttt{models.Film}. Данная композиция изображена на диаграмме классов на чертеже ГУИР.400201.009.РР.1. Также \texttt{models.FilmReview} хранит ссылку на объект синтаксического дерева, в публичном поле \texttt{tree} типа \texttt{models.Tree}. Так как объект синтаксического дерева хранит текст отзыва на фильм в формате синтаксического дерева, то при удалении объекта отзыва на фильм, объект синтаксического дерева должен быть так же удален. Значит, от класса \texttt{models.Tree} направлена связь типа композиция в сторону класса \texttt{models.FilmReview}. Данная связь отражена на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Actor} представляет актера кино на тематическом форуме. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и имя актера.

Так как в каждом фильме может сниматься произвольное количество актеров, а каждый актер может играть роли в произвольном количестве фильмов, то между актером и фильмом связь много ко многим. Поэтому класс \texttt{models.ActorLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом фильма и объектом актера. Класс \texttt{models.ActorLink} имеет публичное поле \texttt{actor} типа \texttt{models.Actor}, которое хранит ссылку на объект класса актера кино на тематическом форуме. При удалении актера свзяь между актером и фильмом так же должна разрушаться. Поэтому из класса ассоциативной таблицы \texttt{models.ActorLink} исходит связь вида композиция в сторону класса актера \texttt{models.Actor}. Данная связь отражена на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1. Также \texttt{models.ActorLink} хранит ссылку на объект фильма в публичном поле \texttt{film} типа \texttt{models.Film}. Так как при разрушении объекта фильма связь между фильмом и актером теряет смысл, то объект типа \texttt{models.ActorLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.ActorLink} исходит связь типа композиции в сторону класса фильма \texttt{models.Film}. Данная связь также отражена на диаграмме классов, изображенноей на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Treebank} представляет собой отображение набора синтаксических деревьев, хранящихся в базе данных. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и название набора данных. Название набора данных выбирается одно из ряда:
\begin{itemize}
\item \texttt{sst\_dev};
\item \texttt{sst\_test};
\item \texttt{sst\_train};
\item \texttt{film\_reviews};
\item \texttt{item\_reviews};
\item \texttt{seller\_reviews}.
\end{itemize}
Код \texttt{sst} обозначает Stanford Sentiment Treebank --- Стенфордский набор данных. Так же в базе хранятся наборы данных созданные из обзоров на фильмы, полученные из тематического форума --- \texttt{film\_reviews}, из онлайн магазина --- \texttt{item\_reviews}, и также обзоры на продавцов --- \texttt{seller\_reviews}.

Класс \texttt{models.ItemReview} представляет обзор на товар в интернет магазине. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{review\_text} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и текст отзыва на товар. Оценка товара пользователем хранится в публичном поле \texttt{item\_grade} типа \texttt{sqlalchemy.Integer}. Автор отзыва указан ссылкой на объект пользователя в публичном поле \texttt{user} типа \texttt{models.User}. Так как при удалении пользователя, обзор теряет силу и значимость, то необходимо удалять вслед за этим и объект обзора на товар. Таким образом от класса \texttt{models.ItemReview} направлена связь вида композиция в сторону класса \texttt{models.User}, что отображено на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1. В поле \texttt{item} типа \texttt{models.Item} хранится ссылка на объект товара, описанного в данном объекте отзыва. При удалении объекта товара, который описывает текущий объект отзыва на товар, отзыв на товар в интернет магазине так же должен быть удален. Следовательно, от класса \texttt{models.ItemReview} направлена связь типа композиция в сторону класса \texttt{models.Item}. Данная композиция изображена на диаграмме классов на чертеже ГУИР.400201.009.РР.1. Также класс \texttt{models.ItemReview} хранит ссылку на объект синтаксического дерева в публичном поле \texttt{tree} типа \texttt{models.Tree}. Так как объект синтаксического дерева хранит текст отзыва в формате синтаксического дерева, то при удалении объекта отзыва на товар в интернет магазине, объект синтаксического дерева должен быть так же удален. Значит, от класса \texttt{models.Tree} направлена связь типа композиция в сторону класса \texttt{models.ItemReview}. Данная композиция также отображена на диаграмме классов, изображенной на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Director} представляет режиссера кино на тематическом форуме. Имеет два публичных поля: \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{name} типа \texttt{sqlalchemy.String} хранящие соответственно идентификатор в базе данных и имя режиссера.

Так как в каждом фильме может участвовать произвольное количество режиссеров, а каждый режиссер может снимать произвольное количество фильмов, то между режиссером и фильмом связь много ко многим. Поэтому класс \texttt{models.DiretorLink} представляет собой ассоциативную таблицу, а какждый объект данного типа будет представлять связь между объектом фильма и объектом режиссера. Класс \texttt{models.DirectorLink} имеет публичное поле \texttt{director} типа \texttt{models.Director}, которое хранит ссылку на объект класса режиссера кино на тематическом форуме. При удалении режиссера свзяь между режиссером и фильмом так же должна разрушаться. Поэтому из класса ассоциативной таблицы \texttt{models.DirectorLink} исходит связь вида композиция в сторону класса режиссера \texttt{models.Director}. Данная связь отражена на диаграмме классов на чертеже ГУИР.400201.009.РР.1. Также \texttt{models.DirectorLink} хранит ссылку на объект фильма в публичном поле \texttt{film} типа \texttt{models.Film}. Так как при разрушении объекта фильма связь между фильмом и его режиссером теряет смысл, то объект типа \texttt{models.DirectorLink} также должен быть уничтожен. Таким образом от класса ассоциативной таблицы \texttt{models.DirectorLink} исходит связь типа композиции в сторону класса фильма \texttt{models.Film}. Данная композиция также отражена на диаграмме классов, изображенноей на чертеже ГУИР.400201.009.РР.1.

Класс \texttt{models.Tree} представляет объект синтаксического дерева. Публичные поля \texttt{id} типа \texttt{sqlalchemy.Integer} и \texttt{json} типа \texttt{sqlalchemy.String} хранят соответственно идентификатор в базе данных и представление синтаксического дерева в формате JSON\@. Поле \texttt{treebank} типа \texttt{models.Treebank} хранит ссылку на объект набора данных. Так как синтаксическое дерево может быть независимым и не входить ни в один из наборов данных, но иимеет поле ссылки на \texttt{models.Treebank}, то между классами набора данных и синтаксического дерева создается связь вида агрегация направленная он \texttt{models.Tree} в сторону \texttt{models.Treebank}. Данная агрегация отображена на диаграмме классов на чертеже ГУИР.400201.009.РР.1.
\subsection{Модуль сбора статистики}
Модуль сбора статистики, описанный в downloader.py в виде класса Downloader, осуществляет сбор статистики с интернет ресурсов, и сохраняет её в базе данных. Для работы с базой класс имеет поля \texttt{session} типа \texttt{sqlalchemy.Session} и \texttt{db\_driver} типа \texttt{sqlalchemy.DbDriver}. В объекте \texttt{db\_driver} содержится информация о подключении к базе данных:
\begin{itemize}
\item база данных (MySQL\@ или PostgreSQL\@)
\item драйвер базы данных для \texttt{Python} (напрмер \texttt{oursql} или \texttt{pymysql})
\item адрес хоста базы;
\item имя базы;
\item логин;
\item пароль.
\end{itemize}
Далее он имеет конфигурируемые переменные \texttt{FILM\_TOKEN\_LEN} и \texttt{ITEM\_TOKEN\_LEN}, заданные глобально в модуле Python. Это стандартная практика для защиты конфигурации. Данные переменные задают количество скачиваемых объектов за один REST запрос для фильмов и товаров соответственно. В константах \texttt{STORE\_URL} и \texttt{FILM\_FORUM\_URL} хранятся URL целевых ресурсов. Массивы \texttt{item\_reviews}, \texttt{seller\_reviews} и \texttt{film\_reviews} хранят соответственно объекты реляционного отображения таблиц с отзывами.

Класс \texttt{Downloader} содежрит набор схожих методов:
\begin{itemize}
\item \texttt{get\_items};
\item \texttt{get\_film};
\item \texttt{get\_categories};
\item \texttt{get\_stores};
\item \texttt{get\_sellers};
\item \texttt{get\_achivements};
\item \texttt{get\_actors};
\item \texttt{get\_directors};
\item \texttt{get\_subcategories}.
\end{itemize}

Задача данных методов в том, чтобы преобразовать полученный от интернет ресурса GET ответ в формате JSON в объек объектно реляциоонного отображения, создав тем самым соответствующую запись в базе данных. Каждый из этих методов имеет константу, хранящую часть путь в URL адресе. Далее имеется переменная {\texttt{params}} типа \texttt{dict}, хранящая параметры REST запросов. Пример объявления \texttt{params} показан ниже:

\medskip
\begin{lstlisting}[style=Python]
  params = {'sortBy': 'recentlyCreated',
    'group': 'general',
    'page': 1,
    'pageSize': self.FILM_PAGE_SIZE}
\end{lstlisting}
\medskip

Переменная \texttt{response} типа хранит ответы на REST запросы. Так же множество различных локальных переменных введены для хранения промежуточных результатов преобразования из JSON в объект. Методы \texttt{save\_film\_info} и \texttt{save\_item\_info} формируют конечную транзацкию в базу данных.

Наконец, задача метода \texttt{get\_missing} проверить целостность данных в базе. Для этого используется схожий набор переменных: \texttt{params} и \texttt{response} для управления REST запросами. Для проверки целостности со стороны клиента используются массивы класса \texttt{item\_reviews}, \texttt{seller\_reviews} и \texttt{film\_reviews}.
