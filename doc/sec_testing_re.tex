\section{ПРОГРАММА И МЕТОДИКА ИСПЫТАНИЙ}
\label{sec:testing}


Тестирование программного обеспечения - это анализ, проводимый с целью предоставления заинтересованным сторонам информации о качестве тестируемого продукта или услуги. Тестирование программного обеспечения также может обеспечить объективное независимое представление программного обеспечения, которое позволит бизнесу оценить и понять риски внедрения программного обеспечения. Методы тестирования включают в себя процесс выполнения программы или приложения с целью обнаружения ошибок программного обеспечения (ошибок или других дефектов) и проверки пригодности программного продукта для использования.

Тестирование программного обеспечения включает в себя выполнение программного компонента или системного компонента для оценки одного или нескольких интересующих свойств. Как правило, эти свойства указывают, в какой степени испытываемый компонент или система:

\begin{itemize}
\item{отвечает требованиям, которые руководствовались его дизайном и разработкой;}
\item{правильно реагирует на все виды входных данных;}
\item{работает в течение приемлемого времени;}
\item{является достаточно удобной для использования;}
\item{может быть установлена и запущена в своих рабочих средах;}
\item{достигает общего результата, к которому стремятся его заинтересованные стороны.}
\end{itemize}


Поскольку количество возможных тестов для даже простых программных компонентов практически бесконечно, всё тестирование программного обеспечения использует некоторую стратегию для выбора тестов, которые являются выполнимыми для доступного времени и ресурсов. В результате тестирование программного обеспечения обычно (но не исключительно) пытаются выполнить программу или приложение с целью обнаружения ошибок программного обеспечения (ошибок или других дефектов). Задача тестирования --  это итеративный процесс, когда исправление  одной ошибки может привести к нахождению другой ошибки или даже создать новую.

Тестирование программного обеспечения может обеспечить объективную независимую информацию о качестве программного обеспечения и риск его отказа пользователям или спонсорам.

Общий подход к разработке программного обеспечения часто определяет, когда и как проводится тестирование. Например, при поэтапном процессе разработки большинство тестов выполняется после того, как системные требования определены, а затем реализованы в тестируемых программах. Напротив, в рамках подхода (agile) требования, программирование и тестирование часто выполняются одновременно.


В данном проекте для повышения качества разрабатываемой продукции тестирование совершалось по принципу гибкой (agile) модели:

\begin{itemize}
\item{люди и взаимодействие важнее процессов и инструментов;}
\item{работающий продукт важнее исчерпывающей документации;}
\item{cотрудничество с заказчиком важнее согласования изначальных условий контракта;}
\item{готовность к изменениям важнее следования первоначальному плану разработки.}
\end{itemize}

Благодаря концепциям, вложенным в основу гибкой модели тестирования, в результате их применения в проекте наблюдалось максимальная адаптации процесса разработки программного обеспечения к мгновенным изменениям требований заказчика.

В целом тестирование было разделено на два этапа:

\begin{itemize}
\item{первый этап -- тестирование отдельных модулей программы в процессе написания программного кода -- т.н. модульное тестрование;}
\item{второй этап -- тестирование программного продукта целиком -- т.н. интеграционное тестирование.}
\end{itemize}

Оба этапа являются достаточно важными, так как работа каждого из них влияет на процесс проверки качества. Например, без модульного тестирования, при анализе работы программы в целом, будет происходить достаточное количество сбоев, выявить и локализовать которые может оказаться достаточно сложным заданием, в то время как при анализе работы одного модуля неисправность оказывается достаточно очевидной. И обратный случай, работоспособность каждого компонента в отдельности не гарантирует корректное поведение всей программы в целом.

Для модульного тестирования был выбран входищий в стандартную библиотеку фреймворк для модульного тестирования под названием unittest. Unittest поддерживает автоматизацию тестов, разделение кода установки и завершения тестов, агрегацию тестов в коллекции и независимость тестов от структуры отчетности. Модуль unittest предоставляет классы, которые позволяют легко поддерживать эти качества для набора тестов.

При построении модульных тестов программы используется так называемый подход <<AAA>>, что означает <<Arrange, Act, Assert>>. Сущность подхода состоит в том, что модульный тест заключает в себе три фундаментальных действия (некоторые из которых могут быть разделены между различными тестами одного набора, покрывающими один компонент).

\begin{itemize}
\item{часть <<Arrange>> подразумевает установку компонента в требуемое исходное состояние путем инициализации компонента нужными значениями, вызовами мутирующих внутреннее состояние методов и т.д;}
\item{часть <<Act>> подразумевает выполнение тестируемого действия. Как правило заключается в вызове тестируемого метода или группы методов;}
\item{часть <<Assert>> заключается в проверке результатов вызова тестируемого действия, соответствия внутреннего состояния системы ожидаемому по завершению вызова, факте наличия либо отсутствия необработанных исключений и т.д;}
\end{itemize}

\begin{lstlisting}[language=TypeScript, label=lst:testing:sample]
import unittest
import HelloWorld
 # TestModule test suite
class TestStringMethods(unittest.TestCase):
   # Initialization - Arrange
   hello_world = HelloWorld()

   # Unit test
    def test_upper(self):
        # Act & Assert
        self.assertEqual('foo'.upper(), 'FOO')
        
   # Unit test
    def test_split(self):
        # Arrange
        s = self.hello_world.get_name()
         # Act & Assert
        self.assertEqual(s.split(), ['hello', 'world'])


if __name__ == '__main__':
    unittest.main()
        
    ...
\end{lstlisting}

Следуя вышепреведенному образцу был реализован набор тестов, покрывающий различные классы которые наследуются от \texttt{FeatureEx-} \\ \texttt{tractorMode}.


Одной из сложностей модульного тестирования является написание такого модуля, чьи зависимости от других модулей системы максимально абстрагированы и отделены друг от друга. Иногда ввиду наличия сложных связей между разными модулями, их невозможно тестировать по отдельности (например, в случаях когда существует зависимость одного модуля от другого на этапе компиляции, такая как зависимость в конструкторе). В таких случаях принято использовать так называемые mock-объекты (ложные объекты), реализующие тот же интерфейс, что и модуль, от которого зависит тестируемый, но реализующий логику данного интерфейса достаточно просто, чтобы с гораздо большей долей вероятности не иметь неисправностей в своей реализации.

Произведя тестирование командой \texttt{python unittest -v unit-} \\ \texttt{tests} получаем следующий вывод результатов тестирования:
\begin{lstlisting}[language=TypeScript, label=lst:testing:results]
python -m unittest -v unittests
test_energy (unittests.TestFeatureExtractor) ... ok
test_first_order_autocorrelation (unittests.TestFeatureExtractor) ... ok
test_zero_crossing_rate (unittests.TestFeatureExtractor) ... ok
test_spectal_centroid (unittests.TestFeatureExtractor) ... ok
test_spectral_smoothness (unittests.TestFeatureExtractor) ... ok
test_spectral_spread (unittests.TestFeatureExtractor) ... ok
test_spectral_dissymmetry (unittests.TestFeatureExtractor) ... ok
test_linear_regression (unittests.TestFeatureExtractor) ... ok
test_rolloff (unittests.TestFeatureExtractor) ... ok
test_sfm (unittests.TestFeatureExtractor) ... ok
test_scf (unittests.TestFeatureExtractor) ... ok


----------------------------------------------------------------------
Ran 11 tests in 0.04s

OK
\end{lstlisting}

Для тестирования классов которые наследуются от \texttt{FeatureEx-}

 \texttt{tractorModel} в качестве входных данных использовался кусок синусоиды и её спектр.

\begin{lstlisting}[language=TypeScript, label=lst:testing:results]
import unittest


class TestFeatureExtractor(unittest.TestCase):

    def setUp(self):
       # create seq
        self.test_data = np.linspace(-np.pi * 100, 
        					   np.pi * 100, 
        					   500)
        # get spectral data
        self.test_data_spectre = scipy.fft(self.test_data)

    # test class Energy
    def test_energy(self):
        energy = Energy()
        # get seq energy 
        result = energy.get(self.seq)
        # energy must be greater than zero
        self.assertGreater(result, 0)

   # test class ZeroCrossingRate
    def test_zero_crossing_rate(self):
        zcr = ZeroCrossingRate()
        # get zero crossing rate
        rate =  zcr.get(np.sin(self.test_data))
        real_rate = 200.0 / len(self.test_data)
        self.assertGreater(rate, real_rate)
        
        ...
\end{lstlisting}


Модульное тестирование наиболее эффективно, когда оно является неотъемлемой частью рабочего процесса разработки программного обеспечения. После написания функции или другого блока кода приложения создаются модульные тесты, которые проверяют поведение кода в ответ на стандартные, граничные и некорректные случаи ввода данных, также проверяются любые явные или предполагаемые допущения, сделанные кодом. В практике разработки программного обеспечения, известной как разработка, управляемая тестом, создается модуль тестов перед написанием кода, поэтому модульные тесты используются в качестве технической документации и спецификации функциональности.

После того, как модульные тесты были закончены для большей части функциональности и реализованные методы прошли все необходимые пункты тестирования, началось функциональное тестирование.

Функциональное тестирование является одним из ключевых видов тестирования, задача которого – установить соответствие разработанного программного обеспечения исходным функциональным требованиям заказчика. То есть проведение функционального тестирования позволяет проверить способность информационной системы в определенных условиях решать задачи, нужные пользователям.

В зависимости от степени доступа к коду системы можно выделить два типа функциональных испытаний:
\begin{itemize}
\item тестирование black box (черный ящик) – проведение функционального тестирования без доступа к коду системы;
\item тестирование white box (белый ящик) – функциональное тестирование с доступом к внутренней структуре и коду приложения.
\end{itemize}

Тестирование black box проводится без знания внутренних механизмов работы системы и опирается на внешние проявления ее работы. При этом тестировании проверяется поведение программного обеспечения при различных входных данных и внутреннем состоянии систем. 

Основной информацией для создания тест-кейсов выступает документация (особенно — требования (requirements-based testing). В случае тестирования white box создаются тест-кейсы, основанные преимущественно на коде системы программного обеспечения. Также существует расширенный тип black-box тестирования, включающего в себя изучение кода, – так называемый grey box (серый ящик). Концепция серого ящика заключается в комбинации методов белого ящика и чёрного ящика, состоящая в том, что к части кода и архитектуре доступ есть, а к части — нет.

\begin{table}[t!]
\caption{Тестирование программы}
\label{table:manual:testing}
  \centering
  \begin{tabular}{| >{\raggedright}m{0.18\textwidth}
                  | >{\centering}m{0.30\textwidth}
                  | >{\centering}m{0.26\textwidth}
                  | >{\centering\arraybackslash}m{0.15\textwidth}|}
    \hline
    {\begin{center}
    Модуль
    \end{center} } & Содержание теста & Ожидаемый результат & Тест пройден \\
    \hline
    WavModule & Конвертация MP3 в WAV & WAV-файл лежит в той же директории, что и MP3  & да \\

    \hline
    WavModule & Считываение WAV-файла & Файл считывается в массив & да \\

    \hline
    Preprocessing Module & Разбивка трека на фрагменты & Трек разбивается на заданное количество фрагментов & да \\

    \hline
    Spectral Transformer &  Получение коррелограммы на основе фрагмента трека & Коррелограмма получена и сохранена в массив  & да \\

    \hline
    Feature Processing &  Вычисления МО и СКО  &  МО и СКО вычисленны и сохранены в вектор признаков & да \\

    \hline
    Genre Classification Module & Запуск каждого метода классификации в своём процессе & Выполнения процесса классификации на всех ядрах & да \\

    \hline
    Visualize DataModule & Сохранения графика в pdf & Файл с графиком находится в директории & да \\

    \hline

  \end{tabular}
\end{table}

Тестирование функциональности может проводиться в двух аспектах: требования и бизнес-процессы. Тестирование в перспективе <<требования>>  используют спецификацию функциональных требований к системе как основу для дизайна тестовых случаев (Test Cases). В этом случае необходимо сделать список того, что будет тестироваться, а что нет, приоритезировать требования на основе рисков, а на основе этого приоритезировать тестовые сценарии. Это позволяет сфокусироваться и не упустить при тестировании наиболее важный функционал. 

Тестирование в перспективе <<бизнес-процессы>> используют знание этих самых бизнес-процессов, которые описывают сценарии ежедневного использования системы.

Тестирование данного программного продукта производилось несколькими пользователями на разных компьютерах: 
\begin{itemize}
\item настольный компьютер Intel Core i7, 16 Гб RAM, Ubuntu 17.04; 
\item настольный компьютер Intel Core i5, 32 Гб RAM, Windows 10;
\item ноутбук Intel Core i3, 4 Гб RAM, Windows 7.
\end{itemize}

 В таблице \ref{table:manual:testing} предоставлена информация о прохождении функциональных тестов данным программным обеспечением.\\

Как видно из таблицы, приложение хорошо справилось с тестами, что говорит о высокой работоспособности.





